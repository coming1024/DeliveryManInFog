<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Delivery Man In Fog</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            font-family: sans-serif;
        }

        #ui {
            position: fixed;
            top: 0;
            width: 100%;
            color: white;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            font-size: 16px;
            z-index: 10;
        }

        #card {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: #333;
            color: white;
            padding: 20px;
            border-radius: 16px;
            text-align: center;
            user-select: none;
            font-size: 18px;
            transition: transform 0.3s ease;
        }
    </style>
</head>

<body>
    <div id="ui">
        <span id="position">ä½ç½®: (0, 0)</span> |
        <span id="time">å‰©ä½™æ—¶é—´: 20</span>
    </div>
    <div id="card">å¡ç‰‡åŠ è½½ä¸­...</div>

    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7/dist/pixi.min.js"></script>
    <script>
        const app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: 0x222222,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true,
        });
        document.body.appendChild(app.view);

        const tileSize = 64;
        const mapSize = 8;
        const mapSymbols = [
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['.', 'F', 'T', 'M', 'M', 'T', 'F', '.'],
            ['.', '.', 'F', '.', '.', 'F', '.', '.'],
            ['.', 'M', '.', '.', '.', '.', 'M', '.'],
            ['.', 'M', '.', '.', '.', '.', 'M', '.'],
            ['.', '.', 'F', '.', '.', 'F', '.', '.'],
            ['.', 'F', 'T', 'M', 'M', 'T', 'F', '.'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
        ];

        const units = [];
        const baseTileUrl = './assets/base.png';
        const unitTextures = { driver: './assets/soldier001.png' };
        const fogTextureUrl = './assets/fog.png';

        const overlayTexturesMap = {
            'F': './assets/treePines.png',
            'T': './assets/towerTall.png',
            'M': './assets/rocks.png',
        };

        const mapContainer = new PIXI.Container();
        const fogLayer = new PIXI.Container(); // æ–°å»ºä¸€å±‚
        // app.stage.addChild(fogLayer); // åŠ åœ¨æœ€ä¸Šé¢
        // mapContainer.addChild(fogLayer);
        // mapContainer.setChildIndex(fogLayer, 0);
        const fogTiles = []; // å­˜å‚¨æ¯ä¸ªæ ¼å­çš„é›¾ Sprite
        app.stage.addChild(mapContainer);
        app.stage.addChild(fogLayer); // åŠ åœ¨æœ€ä¸Šé¢

        const toLoad = [
            baseTileUrl,
            unitTextures.driver,
            fogTextureUrl,
            ...Object.values(overlayTexturesMap),
        ];

        const gameState = {
            pos: { row: 0, col: 0 },
            time: 20,
        };

        const cards = [
            {
                text: "å‰æ–¹å²”è·¯å£",
                left: { dx: -2, dy: 0, result: "ä½ å‘å·¦èµ°ä¸¤æ ¼ã€‚" },
                right: { dx: 2, dy: 0, result: "ä½ å‘å³èµ°ä¸¤æ ¼ã€‚" }
            },
            {
                text: "å‘ç°å°é“",
                left: { dx: 0, dy: -1, result: "ä½ å‘ä¸Šèµ°ä¸€æ­¥ã€‚" },
                right: { dx: 0, dy: 1, result: "ä½ å‘ä¸‹èµ°ä¸€æ­¥ã€‚" }
            },
            // {
            //     text: "çŸ³å¤´é˜»æŒ¡",
            //     left: { dx: -1, dy: 0, result: "ä½ ã€‚" },
            //     right: { dx: 1, dy: 0, result: "ä½ å°è¯•å³è¾¹å†²è¿‡å»ã€‚" }
            // },
        ];
        let cardIndex = 0;

        function updateStatusText() {
            document.getElementById('position').innerText = `ä½ç½®: (${gameState.pos.row}, ${gameState.pos.col})`;
            document.getElementById('time').innerText = `å‰©ä½™æ—¶é—´: ${gameState.time}`;
        }

        function loadNextCard() {
            const card = cards[cardIndex % cards.length];
            document.getElementById('card').innerText =
                `ğŸƒ ${card.text}\nğŸ‘ˆ å·¦æ»‘: ${card.left.result}\nğŸ‘‰ å³æ»‘: ${card.right.result}`;
        }

        function handleCardChoice(direction) {
            const card = cards[cardIndex % cards.length];
            const choice = direction === 'left' ? card.left : card.right;

            const driver = units.find(u => u.type === 'driver');
            let { row, col } = gameState.pos;
            let newRow = Math.max(0, Math.min(mapSize - 1, row + (choice.dy || 0)));
            let newCol = Math.max(0, Math.min(mapSize - 1, col + (choice.dx || 0)));

            driver.sprite.x = newCol * tileSize;
            driver.sprite.y = newRow * tileSize;
            gameState.pos = { row: newRow, col: newCol };
            gameState.time -= 1;

            updateStatusText();
            cardIndex++;
            loadNextCard();
            updateFog(); // åˆå§‹æ—¶åˆ·æ–°è§†é‡
        }

        function updateFog() {
            const { row, col } = gameState.pos;

            // æ‰€æœ‰å…ˆè®¾ä¸ºå¯è§ falseï¼ˆå…¨é®ä½ï¼‰
            for (let r = 0; r < mapSize; r++) {
                for (let c = 0; c < mapSize; c++) {
                    fogTiles[r][c].visible = true;
                }
            }

            // å½“å‰æ ¼å’Œä¸Šä¸‹å·¦å³æ ¼è®¾ä¸ºâ€œå¯è§â€ï¼éšè—é›¾
            const directions = [
                { dr: 0, dc: 0 },  // è‡ªå·±
                { dr: -1, dc: 0 }, // ä¸Š
                { dr: -1, dc: -1 }, // ä¸Š
                { dr: 1, dc: 0 },  // ä¸‹
                { dr: 1, dc: 1 },  // ä¸‹
                { dr: 0, dc: -1 }, // å·¦
                { dr: -1, dc: -1 }, // å·¦
                { dr: 0, dc: 1 },  // å³
                { dr: 1, dc: 1 },  // å³
                { dr: 1, dc: -1 },  // å³
                { dr: -1, dc: 1 },  // å³
            ];

            for (const dir of directions) {
                const r = row + dir.dr;
                const c = col + dir.dc;
                if (r >= 0 && r < mapSize && c >= 0 && c < mapSize) {
                    fogTiles[r][c].visible = false; // éšè—é›¾
                }
            }
        }


        const cardDiv = document.getElementById('card');
        let startX = 0;

        // cardDiv.addEventListener('touchstart', e => startX = e.touches[0].clientX);
        // cardDiv.addEventListener('touchend', e => {
        //   const endX = e.changedTouches[0].clientX;
        //   const dx = endX - startX;
        //   if (Math.abs(dx) > 30) handleCardChoice(dx > 0 ? 'right' : 'left');
        // });

        // cardDiv.addEventListener('mousedown', e => startX = e.clientX);
        // cardDiv.addEventListener('mouseup', e => {
        //   const dx = e.clientX - startX;
        //   if (Math.abs(dx) > 30) handleCardChoice(dx > 0 ? 'right' : 'left');
        // });

        cardDiv.addEventListener('click', (e) => {
            const rect = cardDiv.getBoundingClientRect();
            const x = e.clientX - rect.left;

            if (x < rect.width / 2) {
                handleCardChoice('left');
            } else {
                handleCardChoice('right');
            }
        });


        PIXI.Assets.load(toLoad).then(resources => {
            const baseTexture = resources[baseTileUrl];
            for (let y = 0; y < 2; y++) {
                for (let x = 0; x < 2; x++) {
                    const sprite = new PIXI.Sprite(baseTexture);
                    sprite.width = tileSize * 4;
                    sprite.height = tileSize * 4;
                    sprite.x = x * tileSize * 4;
                    sprite.y = y * tileSize * 4;
                    mapContainer.addChild(sprite);
                }
            }

            for (let row = 0; row < mapSize; row++) {
                for (let col = 0; col < mapSize; col++) {
                    const sym = mapSymbols[row][col];
                    if (sym === '.' || !overlayTexturesMap[sym]) continue;
                    const texture = resources[overlayTexturesMap[sym]];
                    const sprite = new PIXI.Sprite(texture);
                    sprite.width = tileSize;
                    sprite.height = tileSize;
                    sprite.x = col * tileSize;
                    sprite.y = row * tileSize;
                    mapContainer.addChild(sprite);
                }
            }

            const fogTexture = resources[fogTextureUrl];
            for (let row = 0; row < mapSize; row++) {
                fogTiles[row] = [];
                for (let col = 0; col < mapSize; col++) {
                    const fog = new PIXI.Sprite(fogTexture);
                    // fog.alpha = 0.9;
                    fog.width = tileSize;
                    fog.height = tileSize;
                    fog.x = col * tileSize;
                    fog.y = row * tileSize;
                    fogLayer.addChild(fog);
                    fogTiles[row][col] = fog;
                }
            }


            const driverTexture = resources[unitTextures.driver];
            const sprite = new PIXI.Sprite(driverTexture);
            sprite.width = tileSize;
            sprite.height = tileSize;
            sprite.x = 0;
            sprite.y = 0;
            mapContainer.addChild(sprite);
            units.push({ sprite, row: 0, col: 0, type: 'driver' });

            centerMap();
            updateStatusText();
            loadNextCard();
            updateFog(); // åˆå§‹æ—¶åˆ·æ–°è§†é‡
        });

        function centerMap() {
            mapContainer.x = (app.screen.width - tileSize * mapSize) / 2;
            mapContainer.y = (app.screen.height - tileSize * mapSize) / 2;
            fogLayer.x = (app.screen.width - tileSize * mapSize) / 2;
            fogLayer.y = (app.screen.height - tileSize * mapSize) / 2;
        }

        window.addEventListener('resize', () => {
            app.renderer.resize(window.innerWidth, window.innerHeight);
            centerMap();
        });
    </script>
</body>

</html>